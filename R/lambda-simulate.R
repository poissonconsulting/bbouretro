# Copyright 2024 Province of Alberta
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Simulate lambda
#'
#' This function uses the output of `bbr_km_survival()` and `bbr_recruitment()`
#' to estimate \eqn{\lambda} using the Hatter-Bergerud equation (Hatter and
#' Bergerud, 1991). Monte Carlo simulation is used to generate confidence limits
#' on \eqn{\lambda}.
#'
#' @param recruitment A data frame generated by `bbr_recruitment()`.
#' @param survival A data frame generated by `bbr_km_survival()`.
#'
#' @return A list that contains two data frames. First one is named raw_values
#'   can contains raw simulated data and the second one is the summary data.
#'
#' @details See the `vignette("Methods", package = "bbouretro")` for
#'   descriptions of the equations used. The raw_values can be plotted using
#'   `bbr_plot_lambda_distributions()` and the summary data frame can be output
#'   using `bbr_lambda_summarize()` or plotted using `bbr_plot_lambda()`.
#'
#' @export
#'
#' @references Hatter, Ian, and Wendy Bergerud. 1991. “Moose Recruitment, Adult
#'   Mortality and Rate of Change” 27: 65–73.
#'
#' @examples
#' \dontrun{
#' bbr_lambda_simulate(recruitment_est, survival_est)
#' }
bbr_lambda_simulate <- function(recruitment, survival) {
  chk_has_data(recruitment)
  chk_has_data(survival)

  chk::check_data(
    recruitment,
    values = list(
      PopulationName = character(),
      Year = integer(),
      estimate = numeric(),
      se = numeric(),
      lower = numeric(),
      upper = numeric(),
      groups = integer(),
      female_calves = numeric(),
      females = numeric(),
      sex_ratio = numeric(),
      p_females = numeric()
    )
  )

  chk::check_data(
    survival,
    values = list(
      PopulationName = character(),
      Year = integer(),
      estimate = numeric(),
      se = numeric(),
      lower = numeric(),
      upper = numeric(),
      mean_monitored = numeric(),
      sum_dead = integer(),
      sum_alive = integer(),
      status = character()
    )
  )
  
  survival <- dplyr::rename(survival, "S" = "estimate",
                            "S_SE" = "se")
  
  recruitment <- dplyr::rename(recruitment, "R" = "estimate",
                            "R_SE" = "se")

  chk_overlap(recruitment, survival, "PopulationName")
  chk_overlap(recruitment, survival, "Year")

  # merge the comp and survival databases
  LambdaSum <- merge(recruitment, survival, by = c("PopulationName", "Year"))
  # Lambda estimate using the H-B equation
  LambdaSum$Lambda <- LambdaSum$S / (1 - LambdaSum$R)
  # total number of groups (projectXYear) for sims
  groups <- nrow(LambdaSum)
  # fix sims at 1000
  sims <- 1000

  # generate random normal data frames for survival and recruitment and group number to each
  # set of 1000 random numbers.  Use seperate random numbers for S and R to ensure independence
  rnnors <- data.frame(rnorm(groups * sims))
  names(rnnors) <- "RannorS"
  rnnors$RannorR <- rnorm(groups * sims)
  rnnors$nrow <- seq_len(nrow(rnnors))
  rnnors$group <- rep(seq(1, groups, 1), 1000)
  rnnors <- dplyr::arrange(rnnors, .data$group)

  # merge the random numbers with input data set based on group/row #
  # this expands the data frame 1000X
  LambdaSum$group <- seq_len(nrow(LambdaSum))
  LambdaSumSim <- merge(LambdaSum, rnnors, by = "group")

  # put the estimated parameters on the logit scale
  LambdaSumSim <- dplyr::mutate(
    LambdaSumSim,
    Slogit = qlogis(.data$S),
    Svarlogit = .data$S_SE^2 / (.data$S^2 * ((1 - .data$S)^2)),
    Rlogit = qlogis(.data$R),
    Rvarlogit = .data$R_SE^2 / (.data$R^2 * ((1 - .data$R)^2))
  )

  # generate random values by adding random variation based on the SE of estimates-transform back to 0 to 1 interval.
  LambdaSumSim <- dplyr::mutate(
    LambdaSumSim,
    RanS = plogis(.data$Slogit + .data$RannorS * (.data$Svarlogit^0.5)),
    RanR = plogis(.data$Rlogit + .data$RannorR * (.data$Rvarlogit^0.5)))

  # random H-B lambda based on simulated R and S
  LambdaSumSim$RanLambda <- LambdaSumSim$RanS / (1 - LambdaSumSim$RanR)
  LambdaSumSim$LGT1 <- ifelse(LambdaSumSim$RanLambda > 1, 1, 0)

  # An abriged data set with raw simulated values for later plotting etc.
  LambdaSumSimR <- LambdaSumSim |>
    dplyr::select(
      "PopulationName", "Year", "S", "R", "Lambda", "RanLambda", "RanS", "RanR"
    ) |>
    tibble::tibble()

  # summary of simulation and percentile based estimated CI's for lambda
  SumLambda <-
    LambdaSumSim |>
    dplyr::group_by(
      .data$PopulationName, .data$Year, .data$S, .data$R, .data$Lambda
    ) |>
    dplyr::summarize(
      Lambda_SE = sd(.data$RanLambda, na.rm = TRUE),
      Lambda_CIL = quantile(.data$RanLambda, 0.025, na.rm = TRUE),
      Lambda_CIU = quantile(.data$RanLambda, 0.975, na.rm = TRUE),
      prop_lgt1 = mean(.data$LGT1),
      mean_sim_survival = mean(.data$RanS, na.rm = TRUE),
      mean_sim_recruitment = mean(.data$RanR, na.rm = TRUE),
      mean_sim_lambda = mean(.data$RanLambda, na.rm = TRUE),
      median_sim_lambda = median(.data$RanLambda)
    ) |>
    dplyr::ungroup() |>
    tibble::tibble()

  SumLambda <-
    dplyr::rename(SumLambda, "estimate" = "Lambda",
           "se" = "Lambda_SE",
           "lower" = "Lambda_CIL",
           "upper" = "Lambda_CIU")
  # create a list that contains raw and summarized output
  LambdaOut <- list(LambdaSumSimR, SumLambda)
  names(LambdaOut) <- c("raw_values", "summary")

  LambdaOut
}

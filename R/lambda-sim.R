# Copyright 2024 Province of Alberta
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Simulate lambda
#'
#' This function uses the summary output of `bbr_km_survival()` and
#' `bbr_recruitment()` to estimate \eqn{lambda} using the Hatter-Bergerud
#' equation. Monte Carlo simulation is used to generate confidence limits on
#' \eqn{lambda}.
#'
#' @param recruitment Input summary data frame generated by `bbr_recruitment()`.
#' @param survival Input summary data frame generated by `bbr_km_survival()`.
#'
#' @details See the vignette Methods for description of equations used. Users
#'   can plot the distribution of simulated \eqn{lambda} values using
#'   `bbr_plot_lambda_distributions()` function as well as estimated values
#'   using the `bbr_plot_lambda()` function.
#'
#' @return A list object that contains raw simulated data and summary data.  The
#'   raw data can be plotted using the `bbr_plot_lambda_distributions()` and the
#'   summary data can be output using the `bbr_lambda_summarize()` function or
#'   plotted using the `bbr_plot_lamba()` function.
#' @export
#'
#' @examples
#' \dontrun{
#' bbr_lambda_simulate(recruitment_est, survival_est)
#' }
bbr_lambda_simulate <- function(recruitment, survival) {
  chk_has_data(recruitment)
  chk_has_data(survival)

  chk::check_data(
    recruitment,
    values = list(
      PopulationName = character(),
      Year = integer(),
      R = numeric(),
      R_SE = numeric(),
      R_CIL = numeric(),
      R_CIU = numeric(),
      groups = integer(),
      FemaleCalves = numeric(),
      Females = numeric(),
      sexratio = numeric(),
      pFemales = numeric()
    )
  )

  chk::check_data(
    survival,
    values = list(
      PopulationName = character(),
      Year = integer(),
      S = numeric(),
      S_SE = numeric(),
      S_CIL = numeric(),
      S_CIU = numeric(),
      MeanMonitored = numeric(),
      sumdead = integer(),
      sumalive = integer(),
      Status = character()
    )
  )

  chk_overlap(recruitment, survival, "PopulationName")
  chk_overlap(recruitment, survival, "Year")

  # merge the comp and survival databases
  LambdaSum <- merge(recruitment, survival, by = c("PopulationName", "Year"))
  # Lambda estimate using the H-B equation
  LambdaSum$Lambda <- LambdaSum$S / (1 - LambdaSum$R)
  # total number of groups (projectXYear) for sims
  groups <- nrow(LambdaSum)
  # fix sims at 1000
  sims <- 1000

  # generate random normal data frames for survival and recruitment and group number to each
  # set of 1000 random numbers.  Use seperate random numbers for S and R to ensure independence
  rnnors <- data.frame(rnorm(groups * sims))
  names(rnnors) <- "RannorS"
  rnnors$RannorR <- rnorm(groups * sims)
  rnnors$nrow <- seq_len(nrow(rnnors))
  rnnors$group <- rep(seq(1, groups, 1), 1000)
  rnnors <- dplyr::arrange(rnnors, .data$group)

  # merge the random numbers with input data set based on group/row #
  # this expands the data frame 1000X
  LambdaSum$group <- seq_len(nrow(LambdaSum))
  LambdaSumSim <- merge(LambdaSum, rnnors, by = "group")

  # put the estimated parameters on the logit scale
  LambdaSumSim <- dplyr::mutate(
    LambdaSumSim,
    Slogit = log(.data$S / (1 - .data$S)),
    Svarlogit = .data$S_SE^2 / (.data$S^2 * ((1 - .data$S)^2)),
    Rlogit = log(.data$R / (1 - .data$R)),
    Rvarlogit = .data$R_SE^2 / (.data$R^2 * ((1 - .data$R)^2))
  )

  # generate random values by adding random variation based on the SE of estimates-transform back to 0 to 1 interval.
  LambdaSumSim <- dplyr::mutate(
    LambdaSumSim,
    RanS = (1 / (1 + exp(-1 * (.data$Slogit + .data$RannorS * (.data$Svarlogit^0.5))))),
    RanR = (1 / (1 + exp(-1 * (.data$Rlogit + .data$RannorR * (.data$Rvarlogit^0.5)))))
  )

  # random H-B lambda based on simulated R and S
  LambdaSumSim$RanLambda <- LambdaSumSim$RanS / (1 - LambdaSumSim$RanR)
  LambdaSumSim$LGT1 <- ifelse(LambdaSumSim$RanLambda > 1, 1, 0)

  # An abriged data set with raw simulated values for later plotting etc.
  LambdaSumSimR <- LambdaSumSim |>
    dplyr::select(
      "PopulationName", "Year", "S", "R", "Lambda", "RanLambda", "RanS", "RanR"
    ) |>
    tibble::tibble()

  # summary of simulation and percentile based estimated CI's for lambda
  SumLambda <-
    LambdaSumSim |>
    dplyr::group_by(
      .data$PopulationName, .data$Year, .data$S, .data$R, .data$Lambda
    ) |>
    dplyr::summarize(
      SE_Lambda = sd(.data$RanLambda, na.rm = TRUE),
      Lambda_LCL = quantile(.data$RanLambda, 0.025, na.rm = TRUE),
      Lambda_UCL = quantile(.data$RanLambda, 0.975, na.rm = TRUE),
      Prop_LGT1 = mean(.data$LGT1),
      meanSimSurv = mean(.data$RanS, na.rm = TRUE),
      meanRsim = mean(.data$RanR, na.rm = TRUE),
      meanSimLambda = mean(.data$RanLambda, na.rm = TRUE),
      medianSimLambda = median(.data$RanLambda)
    ) |>
    dplyr::ungroup() |>
    tibble::tibble()

  # create a list that contains raw and summarized output
  LambdaOut <- list(LambdaSumSimR, SumLambda)
  names(LambdaOut) <- c("RawValues", "Summary")

  LambdaOut
}

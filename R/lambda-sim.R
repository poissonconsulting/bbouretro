# Copyright 2024 Province of Alberta
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Simulate lambda
#'
#' This function uses the summary output of `km_survival()` and `recruitment()`
#' to estimate \eqn{lambda} using the Hatter-Bergerud equation.  Monte Carlo
#' simulation is used to generate confidence limits on \eqn{lambda}.
#'
#' @param recruitment Input summary data frame generated by `recruitment()`
#' @param survival Input summary data frame generated by `km_survival()`
#'
#' @details The basic Hatter-Bergerud equation used to estimate lamba is given
#'   below. \eqn{lambda = (S) / (1 - R)} The standard errors on estimates of
#'   survival and recruitment are then used to create simulated distributions of
#'   S and R and derive a distribution of Î» based on the simulated values.  It
#'   is assumed both survival and recruitment are distributed on the logit scale
#'   therefore bounding each value between 0 and 1.  One thousand simulations
#'   are conducted. Percentile-based confidence limits are then derived.  Also,
#'   the proportion of simulations where \eqn{lambda} is greater than 1 is
#'   tabulated to provide a p-value for the hypothesis test \eqn{(Ho: lambda >=
#'   1, Ha: lambda < 1)}.  Output summaries also include mean values simulated
#'   for \eqn{S}, \eqn{R}, as well as mean and median \eqn{lambda} values from
#'   the simulation.  Users can plot the distribution of simulated \eqn{lambda}
#'   values using `plot_lambda_distributions()` function as well as estimated
#'   values using the `plot_lambda()` function.
#'
#' @return A list object that contains raw simulated data and summary data.  The
#'   raw data can be plotted using the `plot_lambda_distributions()` and the
#'   summary data can be output using the `summarize_lambda()` function or
#'   plotted using the `plot_lamba()` function.
#' @export
#'
#' @examples
#' \dontrun{
#' lambda_sim(recruitment_estimate, survival_est)
#' }
lambda_sim <- function(recruitment, survival) {
  # merge the comp and survival databases
  LambdaSum <- merge(recruitment, survival, by = c("PopulationName", "Year"))
  # Lambda estimate using the H-B equation
  LambdaSum$Lambda <- LambdaSum$S / (1 - LambdaSum$R)

  # total number of groups (projectXYear) for sims
  groups <- nrow(LambdaSum)
  # fix sims at 1000
  sims <- 1000

  # generate random normal data frames for survival and recruitment and group number to each
  # set of 1000 random numbers.  Use seperate random numbers for S and R to ensure independence
  rnnors <- data.frame(rnorm(groups * sims))
  names(rnnors) <- "RannorS"
  rnnors$RannorR <- rnorm(groups * sims)
  rnnors$nrow <- 1:nrow(rnnors)
  rnnors$group <- rep(seq(1, groups, 1), 1000)
  rnnors <- dplyr::arrange(rnnors, .data$group)

  # merge the random numbers with input data set based on group/row #
  # this expands the data frame 1000X
  LambdaSum$group <- 1:nrow(LambdaSum)
  LambdaSumSim <- merge(LambdaSum, rnnors, by = "group")

  # put the estimated parameters on the logit scale
  LambdaSumSim <- dplyr::mutate(
    LambdaSumSim,
    Slogit = log(.data$S / (1 - .data$S)),
    Svarlogit = .data$S_SE^2 / (.data$S^2 * ((1 - .data$S)^2)),
    Rlogit = log(.data$R / (1 - .data$R)),
    Rvarlogit = .data$R_SE^2 / (.data$R^2 * ((1 - .data$R)^2))
  )

  # generate random values by adding random variation based on the SE of estimates-transform back to 0 to 1 interval.
  LambdaSumSim <- dplyr::mutate(
    LambdaSumSim,
    RanS = (1 / (1 + exp(-1 * (.data$Slogit + .data$RannorS * (.data$Svarlogit^0.5))))),
    RanR = (1 / (1 + exp(-1 * (.data$Rlogit + .data$RannorR * (.data$Rvarlogit^0.5)))))
  )

  # random H-B lambda based on simulated R and S
  LambdaSumSim$RanLambda <- LambdaSumSim$RanS / (1 - LambdaSumSim$RanR)
  LambdaSumSim$LGT1 <- ifelse(LambdaSumSim$RanLambda > 1, 1, 0)

  # An abriged data set with raw simulated values for later plotting etc.
  LambdaSumSimR <- LambdaSumSim[c("PopulationName", "Year", "S", "R", "Lambda", "RanLambda", "RanS", "RanR")]

  # summary of simulation and percentile based estimated CI's for lambda
  SumLambda <- plyr::ddply(
    LambdaSumSim, 
    c("PopulationName", "Year", "S", "R", "Lambda"), 
    plyr::summarize,
    SE_Lambda = sd(.data$RanLambda, na.rm = T),
    Lambda_LCL = quantile(.data$RanLambda, 0.025, na.rm = T),
    Lambda_UCL = quantile(.data$RanLambda, 0.975, na.rm = T),
    Prop_LGT1 = mean(.data$LGT1),
    meanSimSurv = mean(.data$RanS, na.rm = T),
    meanRsim = mean(.data$RanR, na.rm = T),
    meanSimLambda = mean(.data$RanLambda, na.rm = T),
    medianSimLambda = median(.data$RanLambda)
  )

  # create a list that contains raw and summarized output
  LambdaOut <- list(LambdaSumSimR, SumLambda)
  names(LambdaOut) <- c("RawValues", "Summary")

  LambdaOut
}

# Copyright 2024 Province of Alberta
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Simulate lambda
#'
#' This function uses the output of `bbr_survival()` and `bbr_recruitment()`
#' to estimate \eqn{\lambda} using the Hatter-Bergerud equation (Hatter and
#' Bergerud, 1991). Monte Carlo simulation is used to generate confidence limits
#' on \eqn{\lambda}.
#'
#' @param recruitment A data frame generated by `bbr_recruitment()`.
#' @param survival A data frame generated by `bbr_survival()`.
#'
#' @return A list that contains two data frames. First one is named raw_values
#'   can contains raw simulated data and the second one is the summary data.
#'
#' @details See the `vignette("Methods", package = "bbouretro")` for
#'   descriptions of the equations used. The raw_values can be plotted using
#'   `bbr_plot_lambda_distributions()` and the summary data frame can be output
#'   using `bbr_lambda_summarize()` or plotted using `bbr_plot_lambda()`.
#'
#' @export
#'
#' @references Hatter, Ian, and Wendy Bergerud. 1991. “Moose Recruitment, Adult
#'   Mortality and Rate of Change” 27: 65–73.
#'
#' @examples
#' \dontrun{
#' bbr_lambda(recruitment_est, survival_est)
#' }
bbr_lambda <- function(recruitment, survival) {
  
  chk::check_data(
    recruitment,
    values = list(
      PopulationName = character(),
      Year = integer(),
      estimate = numeric(),
      se = numeric()
    )
  ) 
  
  chk::check_data(
    survival,
    values = list(
      PopulationName = character(),
      Year = integer(),
      estimate = numeric(),
      se = numeric()
    )
  )
  
  chk_has_data(recruitment)
  chk_has_data(survival)
  
  survival <- dplyr::select(survival, 
                            "PopulationName", 
                            "Year", 
                            "S" = "estimate",
                            "S_SE" = "se")
  
  # merge the comp and survival databases
  LambdaSum <- recruitment |>
    dplyr::select("PopulationName", 
           "Year", 
           "R" = "estimate",
           "R_SE" = "se") |>
    dplyr::inner_join(survival, by = c("PopulationName", "Year")) |>
    dplyr::mutate(estimate = .data$S / (1 - .data$R),
                  group = seq_len(dplyr::n()))
  
  if(!nrow(LambdaSum)) {
    rlang::abort(
      "recruitment and survival must have overlapping values in recruitment and survival."
    )
  }
  
  # total number of groups (projectXYear) for sims
  groups <- nrow(LambdaSum)
  # fix sims at 1000
  sims <- 1000
  
  # generate random normal data frames for survival and recruitment and group number to each
  # set of 1000 random numbers.  Use seperate random numbers for S and R to ensure independence
  # merge the random numbers with input data set based on group/row #
  # this expands the data frame 1000X
  # put the estimated parameters on the logit scale
  # generate random values by adding random variation based on the SE of estimates-transform back to 0 to 1 interval.
  # random H-B lambda based on simulated R and S
  LambdaSumSim <- dplyr::tibble(RannorS = rnorm(groups * sims), 
                                RannorR = rnorm(groups * sims),
                                group = rep(seq(1, groups, 1), sims)) |>
    dplyr::arrange(.data$group) |>
    dplyr::inner_join(LambdaSum, by = "group") |>
    dplyr::mutate(
      Slogit = logit(.data$S),
      SElogit = logit_se(.data$S_SE, .data$S),
      Rlogit = logit(.data$R),
      RElogit = logit_se(.data$R_SE, .data$R),
      RanS = ilogit(.data$Slogit + .data$RannorS * .data$SElogit),
      RanR = ilogit(.data$Rlogit + .data$RannorR * .data$RElogit),
      RanLambda =.data$RanS / (1 - .data$RanR),
      LGT1 = ifelse(.data$RanLambda > 1, 1, 0))
  
  # An abriged data set with raw simulated values for later plotting etc.
  LambdaSumSimR <- LambdaSumSim |>
    dplyr::select(
      "PopulationName", "Year", "S", "R", "Lambda" = "estimate", "RanLambda", "RanS", "RanR"
    ) |>
    tibble::tibble()
  
  # summary of simulation and percentile based estimated CI's for lambda
  SumLambda <-
    LambdaSumSim |>
    dplyr::group_by(
      .data$PopulationName, .data$Year, .data$S, .data$R, .data$estimate
    ) |>
    dplyr::summarize(
      se = sd(.data$RanLambda, na.rm = TRUE),
      lower = quantile(.data$RanLambda, 0.025, na.rm = TRUE),
      upper = quantile(.data$RanLambda, 0.975, na.rm = TRUE),
      prop_lgt1 = mean(.data$LGT1),
      mean_sim_survival = mean(.data$RanS, na.rm = TRUE),
      mean_sim_recruitment = mean(.data$RanR, na.rm = TRUE),
      mean_sim_lambda = mean(.data$RanLambda, na.rm = TRUE),
      median_sim_lambda = median(.data$RanLambda)
    ) |>
    dplyr::ungroup() |>
    tibble::tibble()
  # create a list that contains raw and summarized output
  LambdaOut <- list(LambdaSumSimR, SumLambda)
  names(LambdaOut) <- c("raw_values", "summary")
  
  LambdaOut
}
